name: CI

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Setup Android NDK
      uses: nttld/setup-ndk@v1
      with:
        ndk-version: r27c

    - name: Setup Gradle
      uses: gradle/actions/setup-gradle@v3
      with:
        cache-read-only: ${{ github.ref != 'refs/heads/main' && github.ref != 'refs/heads/master' }}

    - name: Grant execute permission for scripts
      run: |
        chmod +x gradlew
        chmod +x scripts/*.sh
        chmod +x .github/scripts/*.sh

    - name: Install Native Build Dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake build-essential ninja-build

    - name: Build Native Libraries
      run: |
        # Build Whisper JNI
        ./scripts/build_whisper_linux.sh
        # Build SDCPP JNI (needed for Video test, even if we skip it, to ensure build passes)
        ./scripts/build_sdcpp_linux.sh

    - name: Download Test Models
      run: .github/scripts/download_models.sh

    - name: Run Unit Tests
      run: ./gradlew :llmedge:testDebugUnitTest

    - name: Run E2E Tests (Whisper)
      env:
        LLMEDGE_TEST_WHISPER_MODEL_PATH: ${{ github.workspace }}/models/ggml-tiny.en.bin
        LLMEDGE_BUILD_WHISPER_LIB_PATH: ${{ github.workspace }}/llmedge/build/native/linux-x86_64/libwhisper_jni.so
      run: |
        # Explicitly run the Whisper E2E test
        ./gradlew :llmedge:testDebugUnitTest --tests "*WhisperLinuxE2ETest"

    - name: Run E2E Tests (SmolLM Text)
      env:
        # Note: SmolLMInferenceTest in the codebase mocks the native bridge.
        # To enable real E2E testing, we would need a specific Linux E2E test class similar to WhisperLinuxE2ETest.
        # For now, we point to the model so if such a test is added or enabled, it works.
        LLMEDGE_TEST_TEXT_MODEL_PATH: ${{ github.workspace }}/models/SmolLM-135M-Instruct-q8_0.gguf
        # Assuming the library name for text model JNI if different from default or part of llmedge core
        # Usually it's libllm_jni.so or similar, built via gradle or cmake.
      run: |
        echo "SmolLM model available at $LLMEDGE_TEST_TEXT_MODEL_PATH"
        # Since currently SmolLM tests are mocked or instrumented (Android), we just verify the model exists.
        # If there were a host-side E2E test, we would run it here.
        ls -l $LLMEDGE_TEST_TEXT_MODEL_PATH

    - name: Build release AAR
      run: ./gradlew :llmedge:assembleRelease

    - name: Upload AAR
      uses: actions/upload-artifact@v4
      with:
        name: llmedge-release
        path: llmedge/build/outputs/aar/*.aar
